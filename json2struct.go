package main

/**
 * Created by John Tsantilis
 * (i [dot] tsantilis [at] yahoo [dot] com A.K.A lumi) on 11/9/2017.
 */

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"
	"strings"
	"os/user"
	"bytes"
	"io/ioutil"
	"github.com/giannis20012001/GoTest/util"
	b64 "encoding/base64"

)

type Response struct {
	Code         string `json:"code"`
	Message      string `json:"message"`
	ReturnObject ReturnObject `json:"returnobject"`
}

type ReturnObject struct {
	GroundInfo GroundInfo`json:"groundInfo"`
	ComponentInfo ComponentInfo `json:"componentInfo"`
}

type GroundInfo struct {
	PublicIP         string `json:"publicIP,omitempty"`
	PrivateIP        string `json:"privateIP,omitempty"`
	AgentPort        string `json:"agentPort,omitempty"`
	OrchestratorIP   string `json:"orchestratorIP,omitempty"`
	OrchestratorPort string `json:"orchestratorPort,omitempty"`
	GNID             string `json:"GNID,omitempty"`
	GSGID            string `json:"GSGID,omitempty"`
	CNID             string `json:"CNID,omitempty"`
	NID              string `json:"NID,omitempty"`
}

type ComponentInfo struct {
	ClassName string `json:"className"`
	CNID	string `json:"CNID"`
	NativeComponent bool   `json:"nativeComponent"`
	LifecycleInitMethod string `json:"omitempty"`
	LifecycleStartMethod string `json:"omitempty"`
	LifecycleStopMethod string `json:"omitempty"`
	DependencyResolutionHandlers map[string][]string `json:"dependencyResolutionHandlers,omitempty"`
	DependencyBindingHandlers map[string][]string `json:"dependencyBindingHandlers,omitempty"`
	Metrics map[string][]string `json:"metrics,omitempty"`
	ConfigurationParameters map[string][]string `json:"configurationParameters,omitempty"`
	BehavioralProfile map[string][]string `json:"behavioralProfile,omitempty"`
	ExecutionRequirements map[string][]string `json:"executionRequirements,omitempty"`
	ContainerParameters map[string][]string `json:"containerParameters,omitempty"`
}

func main() {
	url := "http://arcadia-sc.euprojects.net/api/v1/node/55/config"
	fmt.Println("URL:>", url)

	usr, err := user.Current()
	if err != nil {
		fmt.Println(err)

	}

	nid := "e475986e-22b7"
	arrNid := []byte(nid)
	publicKey := util.GetPublicKeyPem(usr.HomeDir + "/Dropbox/ubitech/input_arcadia/agent_golang/authorized_keys")
	uEnc, err := util.RsaEncrypt(publicKey, arrNid)
	if err != nil {
		fmt.Println(err)

	}

	authorizationKey := b64.StdEncoding.EncodeToString(uEnc)

	var jsonStr = []byte("parameters")
	req, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonStr))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", authorizationKey)

	client := &http.Client{
		Timeout: time.Second * 10,

	}

	resp, err := client.Do(req)
	if err != nil {
		panic(err)

	}

	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	fmt.Println("response Status:", resp.Status)
	fmt.Println("response Headers:", resp.Header)
	fmt.Println("response Body:", string(body))
	fmt.Println()

	/*a := new(AutoGenerated)
	err = json.Unmarshal(body, &a)
	if err != nil {
		fmt.Println(err)

	}

	fmt.Println(a)*/

	//Get reply and extract json response from body
	var data map[string]interface{}
	if err = json.Unmarshal(body, &data); err != nil {
		fmt.Println(err)

	}

	fmt.Println()
	value := data["returnobject"].(string)
	replacer := strings.NewReplacer("\\", "", "\"{", "{", "}\"", "}")
	result := replacer.Replace(value)
	fmt.Println(result)

	fmt.Println()
	var final map[string]interface{}
	json.Unmarshal([]byte(result), &final)
	fmt.Printf("%v\n", final["groundInfo"].(map[string]interface{})["publicIP"].(string))
	//fmt.Printf("%v", y["componentInfo"].(map[string]interface{})["dependencyResolutionHandlers"].(map[string]interface{})["aea5f833-008e-410d-9b0d-d06f4ffad83a"])

	//
	fmt.Println()
	alpha := new(GroundInfo)
	alpha.OrchestratorIP = final["groundInfo"].(map[string]interface{})["publicIP"].(string)
	alpha.PrivateIP = final["groundInfo"].(map[string]interface{})["privateIP"].(string)
	alpha.AgentPort = final["groundInfo"].(map[string]interface{})["agentPort"].(string)
	alpha.OrchestratorIP = final["groundInfo"].(map[string]interface{})["orchestratorIP"].(string)
	alpha.OrchestratorPort = final["groundInfo"].(map[string]interface{})["orchestratorPort"].(string)
	alpha.GNID = final["groundInfo"].(map[string]interface{})["GNID"].(string)
	alpha.GSGID = final["groundInfo"].(map[string]interface{})["GSGID"].(string)
	alpha.CNID = final["groundInfo"].(map[string]interface{})["CNID"].(string)
	alpha.NID = final["groundInfo"].(map[string]interface{})["NID"].(string)
	fmt.Println(alpha)

	fmt.Println()
	beta := new(ComponentInfo)
	beta.ClassName = final["componentInfo"].(map[string]interface{})["className"].(string)
	beta.CNID = final["componentInfo"].(map[string]interface{})["CNID"].(string)
	beta.NativeComponent = final["componentInfo"].(map[string]interface{})["nativeComponent"].(bool)
	//==================================================================================================================
	//==================================================================================================================

	//beta.DependencyResolutionHandlers
	m := final["componentInfo"].(map[string]interface{})["dependencyResolutionHandlers"]
	temp := make(map[string][]string)
	beta.DependencyResolutionHandlers = temp
	for k, v := range m.(map[string]interface{}) {
		beta.DependencyResolutionHandlers[k] = append(beta.DependencyResolutionHandlers[k], v.(string))

	}

	//beta.DependencyBindingHandlers
	m = final["componentInfo"].(map[string]interface{})["dependencyBindingHandlers"]
	temp = make(map[string][]string)
	beta.DependencyBindingHandlers = temp
	for k, v := range m.(map[string]interface{}) {
		beta.DependencyBindingHandlers[k] = append(beta.DependencyBindingHandlers[k], v.(string))

	}

	//beta.Metrics
	m = final["componentInfo"].(map[string]interface{})["metrics"]
	temp = make(map[string][]string)
	beta.Metrics = temp
	for k, v := range m.(map[string]interface{}) {
		beta.Metrics[k] = append(beta.Metrics[k], v.(string))

	}

	//beta.ConfigurationParameters
	m = final["componentInfo"].(map[string]interface{})["configurationParameters"]
	temp = make(map[string][]string)
	beta.ConfigurationParameters = temp
	for k, v := range m.(map[string]interface{}) {
		beta.ConfigurationParameters[k] = append(beta.Metrics[k], v.(string))

	}

	//beta.BehavioralProfile
	m = final["componentInfo"].(map[string]interface{})["behavioralProfile"]
	temp = make(map[string][]string)
	beta.BehavioralProfile = temp
	for k, v := range m.(map[string]interface{}) {
		beta.BehavioralProfile[k] = append(beta.BehavioralProfile[k], v.(string))

	}

	//beta.ExecutionRequirements
	m = final["componentInfo"].(map[string]interface{})["executionRequirements"]
	temp = make(map[string][]string)
	beta.ExecutionRequirements = temp
	for k, v := range m.(map[string]interface{}) {
		beta.ExecutionRequirements[k] = append(beta.ExecutionRequirements[k], v.(string))

	}

	//beta.ContainerParameters
	m = final["componentInfo"].(map[string]interface{})["containerParameters"]
	temp = make(map[string][]string)
	beta.ContainerParameters = temp
	for k, v := range m.(map[string]interface{}) {
		beta.ContainerParameters[k] = append(beta.ContainerParameters[k], v.(string))

	}

	fmt.Println(beta)

}